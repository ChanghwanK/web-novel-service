# Project Overview
Numble에서 주관하는 웹소설 서비스 클론 코딩 프로젝트이며 '네이버 웹소설' 서비스를 타겟팅 하였습니다.

## 프로젝트 주요 목표
1. 확장성이 뛰어나고 변경에 유연한 소프트웨어를 설계합니다.
2. 정규화된 데이터의 단점을 극복하고 대규모 트래픽에도 빠른 조회 성능을 보장할 수 있어야 합니다.
3. 포인트 충전 시 발생할 수 있는 중복 결제 문제(동시성 이슈)를 단건만 결제됨을 보장할 수 있어야 합니다.

## 고민한 것들
1. 확장성이 뛰어나고 변경에 유연한 소프트웨어를 만들 수 있을까 Feat. Hexagonal
2. 조회수 처리에 대한 고민 Feat. Race Condition 개선과 Lock 제거하여 성능 향상 시키기 + Spring Batch
3. 효율적인 수정과 빠른 데이터 조회를 위한 READ 모델 분리하기
4. 포인트 중복 충전을 막는 방법

### 고민1. 어떻게 하면 더 확장성이 뛰어나고 유연한 소프트웨어를 만들 수 있을까? -> [전체 글 보러가기](https://github.com/ChanghwanK/web-novel-service/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-(Feat.-%EB%A0%88%EC%9D%B4%EC%96%B4%EB%93%9C-vs-%ED%97%A5%EC%82%AC%EA%B3%A0%EB%82%A0))
- 빠르게 변화하는 고객 니즈들에 맞춰 서비스 또한 빠르게 확장하고 변경될 수 있어야 하는 것은 선택이 아닌 필수 
- 따라서 DIP 설계 원칙을 바탕으로 `Port`와 `Adapter` 개념을 활용하여 `변화`와 `확장`에 용이한 헥사고날 아키텍처 선택

![웹소설 네트워크 지연-페이지-7 drawio](https://user-images.githubusercontent.com/83544156/232976944-c28ee5c6-7b8a-43f1-a2b4-9e8e0494b452.png)


<br>

### 고민2. 조회수 처리에 대한 고민 (테이블 컬럼을 이용해 카운팅 vs 별도 테이블 분리) -> [전체 글 보러가기](https://github.com/ChanghwanK/web-novel-service/wiki/%EC%A1%B0%ED%9A%8C%EC%88%98-%EC%B2%98%EB%A6%AC%EC%97%90%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC)

**테이블 분리하는 것이 유리하다고 판단**
- 웹소설 서비스는 빠른 조회 트래픽 비중이 높은 비즈니스이기 때문
  - 테이블 컬럼을 사용하는 경우, 동시성 처리를 위한 DB Table단의 비관적 Lock이 필요하기에 성능 문제로 제외

**테이블 분리시 발생한 문제점**
- 조회수 조회를 위해선 집계 쿼리가 발생 -> 조회수 관련 요청이 많아지면 DB 부하가 커짐

**해결**
-  조회수는 배치를 통해 주기적으로 집계 처리를 하고 `Novel` Table의 `view_count` 컬럼을 만들어 집계된 결과를 업데이트 

![웹소설-페이지-3 drawio (1)](https://user-images.githubusercontent.com/83544156/231653777-5acd797c-058e-473e-84eb-29ae3ac40502.png)


**결정 근거**
- 조회수 라는 데이터의 특성을 생각하면 실시간성이 중요한 포인트가 아니기 때문
- 추가로 비즈니스 모델에서 실시간으로 정확성을 요구하는 모델이 없기 때문


**Spring Batch 도입 근거 Feat. 스프링의 스케줄러를 활용하기 어려운 이유**
- 인기 웹소설의 경우 집계해야할 데이터량이 짧은 시간에도 많이 생길 수 있음 
- 집계해야할 웹소설이 많아질 경우 스케줄러로는 한계가 명확함 
  - 많은 양의 데이터를 빠르게 집계하기 위한 다양한 API를 지원하지 않음(parallel 처리등)
  - 시스템 자원을 많이 필요로 할 것인데 같은 서버에서 주기적으로 집계 처리가 이루어지면 다른 API들이 영향을 받을 수 있음
- 현재는 구현하지 않았지만 일별 결제 집계 등 집계 처리가 필요한 경우 배치 도입이 필요하기에 이후 확장성을 고려했을 때도 도입하는 것이 적합하다 판단


<br>


### 고민3. 어떻게 효율적으로 '선호작' 데이터를 관리할 수 있을까? -> [전체 글 보러가기](https://github.com/ChanghwanK/web-novel-service/wiki/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-'%EC%84%A0%ED%98%B8%EC%9E%91'-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C%3F--Feat.%EC%A1%B0%ED%9A%8C-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EB%B6%84%EB%A6%AC%ED%95%98%EC%97%AC-%EA%B4%80%EB%A6%AC%ED%95%98%EC%9E%90)

- **네이버 웹소설 리서치 결과 작품 정보가 변경될 시 선호작 목록의 데이터들 (`제목` `작가 닉네임` `업로드 시간`) 또한 바로 반영되는 것으로 확인**

<img width="700" height="250" alt="선호작 페이지 예시" src="https://user-images.githubusercontent.com/83544156/230811166-8730a786-21ba-4e05-a020-a596e6ae62e4.png">

#### 문제점
- 웹소설 서비스는 READ 트래픽이 높은 서비스인데 '선호작' 목록을의 데이터를 구성하기 위해선 정규화된 데이터를 `JOIN`하여 가져와야 함
  - ex) 최근 업로드된 챕터의 타이틀, 챕터 업로드 시간 등
- 따라서 READ 트래픽이 높아질 경우 부하가 커짐

#### 그렇다면 역정규화 하여 `선호작` 테이블에 소설 정보를 함께 저장하면 어떨까?
- JOIN은 발생하지 않아 READ 트래픽이 높아도 DB 부하가 JOIN이 발생하는 경우보다 높지 않음

**문제점**
- 소설정보가 업데이트될 때 선호작으로 등록된 횟수만큼 Update 쿼리가 발생
  -  리서치 결과 최대 2만번 선호작으로 등록된 소설들이 존재함 이 경우 2만개의 데이터를 찾아서 일일히 다 업데이트해야 함 <- 많은 작품이 연재되는 시간(23시~24시 사이)에는 특히나 업데이트가 매우 많이 일어날 것으로 예상됨 <- 따라서 해당 시간에 DB 부하가 너무 커져 장애로 번질 수 있다 판단

#### 따라서 정규화는 진행하고, READ 모델을 분리하는 것이 적합하다 판단
**근거**
- 정규화를 통해 작품 정보가 변경될 떄 최대 2만건의(2023.04 기준 최대 선호작 수는 2만개) Update 쿼리가 일어나는 것을 막음 
- 선호작 목록 조회 매번 JOIN이 발생하는 문제는 **조회 모델을 분리**하고 `Look Aside` 캐싱 전략을 이용해 캐싱해둘 경우 Join문이 발생하는 문제 해결 가능
- 캐싱 전략은
  -  `Look Aside` 전략을 적용  (반복적인 읽기가 많은 호출에 적합.)

- 이유는
   - 메모리 절약과 빠른 응답을 위해
   - 조회 요청 발생시 Cache Miss 경우에만 필요한 정보를 DB에서 조회 후 캐싱 <- 모든 소설 READ 모델이 캐싱되는 것이 아니기 때문에 메모리 절약이 가능하고 <- 반복적인 읽기가 많은 인기소설들을 위한 공간 확보가 더 가능하기 때문

![선호작조회 FlowChart-페이지-2 drawio](https://user-images.githubusercontent.com/83544156/230818966-dacc35e7-f60e-403e-994e-7b7d6edaea0f.png)


<br>

### 고민4. 중복 결제 요청 시 단건만 진행되도록 하기 (동시성 처리) -> [전체 글 보러가기](https://github.com/ChanghwanK/web-novel-service/wiki/%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%A4%91%EB%B3%B5-%EC%B6%A9%EC%A0%84%EC%9D%84--%EB%A7%89%EC%95%84%EB%9D%BC)

**문제 상황: 결제 요청에 동시성 이슈가 발생**

`클라이언트` -> `서버`로 결제 요청 시 모종의 네트워크 지연이 발생해, 클라이언트는 2번~3번 요청을 더 보낸 상황에 첫번째로 보낸 요청이 2,3번째 보낸 요청과 거의 동시에 서버에 도달하면 N건의 동일한 결제 요청이 동시에 발생하는 문제가 있을 수 있습니다.

![웹소설 네트워크 지연 drawio](https://user-images.githubusercontent.com/83544156/232362557-c473c2a9-a768-48ca-9f01-daf5359f686d.png)


**분산 락을 활용하여 동시성 처리**
- DB Unique 제약조건을 활용할 경우 동일한 요청이지만 분이 달라 '중복 키' 값이 달라지는 경우가 생김 (59분59.99999초 00분00.000001초) <- 중복 결제가 진행됨
- DB 저장전 Key 값이 Redis에 있는지 조회 후 없는 경우에만 Key 값을 Redis에 저장 후 결제 요청이 진행되도록 프로세스 개선 
  - 이 과정에 Redission이 지원하는 분산 Lock을 활용해 동시성 핸들링 <- 동시성을 처리하지 않으면 Key값 조회 시 없을 수 있기 때문

![웹소설 네트워크 지연-페이지-2 drawio (3)](https://user-images.githubusercontent.com/83544156/232376479-ba0d052b-a8cd-4aca-b41b-fedf1eb25cd3.png)


## 개선 방향
- 안정성을 높이기 위해 테스트 코드 작성이 필요합니다.
- 서비스가 얼만큼 부하를 받을 수 있는지 확인 후, 목표치만큼 부하를 견딜 수 있게 개선해야 합니다.
  - 필요하다면 Application을 분산 환경으로 구축합니다.
- I/O 부하 줄이기
  - 챕터 조회시 조회 로직과 조회수 증가 로직이 하나의 트랜잭션으로 묶여있습니다.
  - Message Queue 등을 활용해 비동기방식으로 I/O 부하를 분리할 여지가 있습니다.
 
### Appendix
- 새로운 아키텍처 방법으로 개발한다고 시간 문제로 인해 테스트 코드를 작성하지 못했습니다.
- 실제 운영 서비스로 올릴 것을 가정한다면 Logging을 조금더 디하게 해야합니다.

